Part 1:
    synchronization primitives: Semaphores
    data structure for storing threads and semaphores is array of repective type and the philosphers are considered to be threads
    logic of the program:
    there could be ny order in which the philosphers can access the fork(as requirement of one more fork as have one fork by default) of other philopshers next to them from these possible combinations there would be only one case where each of the philospher follow the similar fashion of accesing the fork from the other philopshers creating similar dependency on each other and since it is similar no one can break this condition hence the state os deadlock is reached and to remove this condition form the arrangements we implement the logic by the help of the semaphores where we we used five sempahores with s[i] as a lock for ith fork and initialized via sem_init(). as described above the lock is applied to the fork is such a way that n-1(4) philosphers have similar method of accessing the forks while the single(1) philospher have opposite way of accessing the forks we achieved this with the help of if and else statement on a thread passed along with some number as an identifer for the thread as which philospher so that we can decide for this philospher we have to apply these locks(since there are various combinations possible for the access of the forks for the situation of deadlock therfore we have used the case where they have their fork on the left side of plate and they access the other fork from the right side but as mentioned any one of them would take from left side to avoid deadlock). after the locks are made then we simply remove the locks in the same fashion as we applied the loacks via if nd else statement.


Part 2:
    No the deadlock is not possible
    Reason:there could not be any arrangement possible which could lead the philosphers into a state each of them dependent on other philospher(means that any philospher has not any requirement to have food availaible to other philospher ) and every philospher is able to get the sauce bowl with no race conditions via the smaphores concept.

Part3:
    Synchronization Primitives:Semaphores
    data structure used is array for storing the no of threads created and the array of size 5 and 4 for storing the semaphore for the logic of fork and other one for the logic of the sauce bowls.
    we break down this problem into two parts first is accesing the fork and other is for the accesing of the sauce bowls. the first part of accessing the fork is same as the "Part 1" of the question we perform the locking operation on the forks after we perform the locks on the forks the part 2 of the question arises where we apply the loack on one of the four sauce bottles and the bottle number is randomly generated by the rand() function after loack on bottles we perform the post or umlocking  operation on the bottles and similar to fork's for usage to other philosphers and in this way we prevent the deadlock.