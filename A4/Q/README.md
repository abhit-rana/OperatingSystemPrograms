user space data structure used both by P and C: Array[8 bytes size]
kernel space data structure used: array of pointers[char type] declared global(size 6)[WE MAKE THIS ARRAY AS QUEUE STORING THE 8 BYTE BLOCKS SEND BY THE PRODUCER], global count variable, static in and out variable for the enqueue and dequeue function respectively and also two instances of semaphore struct are made global(one instance is for the control of the queue to be empty(semEmpty with count as 6) and other is made for the control of the queue to be full(semFull with count as 0))

source files modified:
1. syscall_64.tbl: registering the custom system call to the table containing all system calls and their type*(32 or 64 or etc.)
2. sys.c: implementing the system calls which we have registered on the table consisting of the all system calls. here other helper functions are also made to help the system calls in achiving the desired behaviour by the program. also here the array storing the bytes send by P are stored globally.

logic of the program:
In the user space we create a program which forks two child processes whom which we call the P and C. the P program opens the urandom device file through open() and read the 8 bytes from the file and then pass those 8 bytes to the system call writer() which copy the bytes send from the user process into the kernel space via __copy_from_user() and then we pass those 8 bytes to the enqueue function in the kernel space where before enqueuing the bytes first down(semEmpty) is performed and based on its result the process either goes to sleep or to running the critical section(where the data is enqueued) and then it performs up(semFull) and then exits and whenever the turn of the C process comes which calls the reader system call through user space with array as an argument in which the dequeued value by kernel would be copied and then the reader system call calls the dequeue function where the down(semFull) is performed and based on its result further execution happens if the process executes the critical state then the bytes are dequeued and returned to the reader system call before performing the up(semEmpty) and in the dequeue system call the kernel copies the returned bytes from the dequeue function(present in kernel space) to the user space array which was passed as an argument to the reader() system call with the help of the __copy_to_user() function and then the proccess returns to the user space and this cycle of calling the system calls via P and C happens continuously via while(1).